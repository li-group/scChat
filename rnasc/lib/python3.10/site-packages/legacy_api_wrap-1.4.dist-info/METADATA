Metadata-Version: 2.1
Name: legacy-api-wrap
Version: 1.4
Project-URL: Source, https://github.com/flying-sheep/legacy-api-wrap
Author-email: "Philipp A." <flying-sheep@web.de>
License-Expression: GPL-3.0-or-later
License-File: LICENSE
Classifier: Development Status :: 5 - Production/Stable
Classifier: Intended Audience :: Developers
Classifier: Programming Language :: Python :: 3
Classifier: Topic :: Software Development :: Libraries :: Python Modules
Requires-Python: >=3.8
Provides-Extra: test
Requires-Dist: coverage; extra == 'test'
Requires-Dist: coverage-rich; extra == 'test'
Requires-Dist: pytest; extra == 'test'
Requires-Dist: toml; extra == 'test'
Description-Content-Type: text/x-rst

Legacy API Wrapper |b-pypi| |b-codecov|
=======================================

.. |b-pypi| image:: https://img.shields.io/pypi/v/legacy-api-wrap.svg
   :target: https://pypi.org/project/legacy-api-wrap
.. |b-codecov| image:: https://codecov.io/gh/flying-sheep/legacy-api-wrap/graph/badge.svg
   :target: https://codecov.io/gh/flying-sheep/legacy-api-wrap

This module defines a decorator to wrap legacy APIs.
The primary use case is APIs defined before keyword-only parameters existed.

>>> from legacy_api_wrap import legacy_api

We have a function with many positional parameters lying around:

>>> def fn(a, b=None, d=1, c=2):
...     return c, d, e

We want to convert the positional parameters ``d`` and ``c`` to keyword-only,
change their order and add a parameter. For this we only need to specify name
and order of the old positional parameters in the decorator.

>>> @legacy_api('d', 'c')
... def fn(a, b=None, *, c=2, d=1, e=3):
...     return c, d, e

After adding the decorator, users can keep calling the old API and get a
``DeprecationWarning``:

>>> fn(12, 13, 14) == (2, 14, 3)
True
